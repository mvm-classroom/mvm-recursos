# Cheatsheet PostgreSQL

## Connexi√≥ a bases de dades amb `psql`

### Conectar a base de dades local en mode `Peer`
```shell
sudo -u postgres psql
```
### Conectar a base de dades local en mode `Host`
```shell
psql -h localhost -U postgres
```
### Conectar a base de remota
```shell
psql -h ip.de.equip.servidor -U postgres
```

>[!NOTE]
>En aquest cas estem fent servir sempre l'usuari `postgres` per defecte, pero tingueu en compte que `-u` i `-U` precedeixen el nom d'usuari

## Algunes comandes d'utilitat a `psql`

|Comanda|Descripci√≥|
|---|---|
|`\l`|Llistar totes les bases de dades|
|`\c nom_bdd`|Connectar a una base de dades|
|`\dt`|Llistar les taules de la base de dades|
|`\dt+`|Llistar les taules de la base de dades amb m√©s detall|
|`\d nom_taula`|Mostrar descripci√≥ de la taula|
|`\du`|Llistar usuaris/rols|
|`\dn`|Llistar esquemes|
|`\i fitxer.sql`|Executar un fitxer|
|`\o fitxer.txt`|Redirigir la sortida a un fitxer|
|`\h`|Ajuda de comandes `SQL`|
|`\?`|Ajuda de comandes `psql`|
|`\q` o `exit`|Sortir de `psql`|

## Exemple de c√†rrega de les dades
Connectat al servidor i, fent servir el terminal, fes el necessari per carregar les dades de [`dvdrental.tar`](https://github.com/mvm-classroom/mvm-recursos/raw/main/cicles/ASIX/ASGBD/Recursos/dvdrental.tar). Potser t'interessa fer una ullada a l'eina [`pg_restore`](https://www.postgresql.org/docs/current/app-pgrestore.html)

### Abans de res, hauriem de crear la base de dades.
Connectem al SGBD com l'usuari `postgres`
```shell
psql -h localhost -U postgres
```
i un cop a dins, creem la base de dades
```sql
CREATE DATABASE dvdrental OWNER postgres;
```
### Descarregar el fitxer amb la base de dades
Podem descarregar el fitxer `dvdrental.tar` fent

```shell
wget https://github.com/mvm-classroom/mvm-recursos/raw/main/cicles/ASIX/ASGBD/Recursos/dvdrental.tar
```
### Revisar i importar el fitxer amb la base de dades
Per tafanejar el fitxer `dvdrental.tar` abans d'importarlo a cegues
```shell
pg_restore --list dvdrental.tar
```

Un exemple de com restaurar el fitxer `dvdrental.tar` a la base de dades `dvdrental` que hem creat pr√®viament

```shell
pg_restore -h localhost -U postgres -d dvdrental dvdrental.tar
```

## Tipus de dades
Podeu consultar, de manera molt m√©s extensa i detallada, tota la documentaci√≥ sobre tipus de dades [a aquest cap√≠tol de la documentaci√≥ de PostreSQL 18.](https://www.postgresql.org/docs/current/datatype.html)

### Tipus num√©rics

|Nom|Tamany|Descripci√≥|Rang de valors|
|---|---|---|---|
smallint|2 bytes|enter petit|-32768 a +32767
integer|4 bytes|enter|-2147483648 a +2147483647
bigint|8 bytes|enter gran|-9223372036854775808 a +9223372036854775807
numeric|variable|precisi√≥ especificada per l'usuari, exacte|fins a 131072 digits abans del punt decimal; fins a 16383 digits despr√©s del punt decimal
decimal|variable|sin√≥nim de numeric, exacte|fins a 131072 digits abans del punt decimal; fins a 16383 digits despr√©s del punt decimal
real|4 bytes|precisi√≥ variable, inexacte|Precisi√≥ de 6 digits decimals
double precision|8 bytes|precisi√≥ variable, inexacte|Precisi√≥ de 15 digits decimals
smallserial|2 bytes|petit enter autoincremental|1 a 32767
serial|4 bytes|enter autoincremental|1 a 2147483647
bigserial|8 bytes|enter autoincremental gran|1 a 9223372036854775807

>[!NOTE]
>En realitat `smallserial`,`serial` i`bigserial` no son tipus. Son _√†lies_ que ens simplifiquen la gesti√≥ dels camps autoincrementals i la seq√º√®ncia que han de portar associada per controlar la numeraci√≥.
>
>Es a dir, quan, per exemple, fem:
>```sql
>CREATE TABLE clients (
>    id SERIAL
>);
>```
>en realitat estem definint una estructura com aquesta:
>```sql
>CREATE SEQUENCE clients_id_seq AS integer;
>CREATE TABLE clients (
>    id integer NOT NULL DEFAULT nextval('clients_id_seq')
>);
>ALTER SEQUENCE clients_id_seq OWNED BY clients.id;
>```

Aix√≥, a l'hora de definir permisos, ens pot donar algun mal de cap. Tamb√© s'allunya del SQL m√©s estandaritzat.

Per aix√≥, tenim la alternativa `GENERATED BY DEFAULT AS IDENTITY`

### `GENERATED BY DEFAULT AS IDENTITY`

No l'hem de pensar com una √∫nica opci√≥, ja que es composa de 3 parts: `GENERATED` + `BY DEFAULT` + `AS IDENTITY` 

#### `GENERATED`: 
Indica a PostgreSQL que el sistema s'encarregar√† de crear el valor d'aquesta columna. No √©s un camp est√†tic, sin√≥ un camp **calculat** o **produ√Øt** pel motor.

#### `BY DEFAULT`: 
Defineix quan actua el sistema. Aqu√≠ √©s on tens dues opcions: `BY DEFAULT` o `ALWAYS`.

 - `BY DEFAULT`: El podem entendre com: *Si no ens informen el valor, agafo el seg√ºent n√∫mero de la seq√ºencia. Si ens informen el valor, ens quedarem amb aquest valor.*
 
 - `ALWAYS`: El podem entendre com: *Els valors sempre s'agafar√†n de la seq√ºencia, no m'interessa que ning√∫ insereixi cap valor manual perque em poden desincronitzar la seq√ºencia.* Si alg√∫ intenta informar el valor manualment, donar√† error.
 

#### `AS IDENTITY`:
El podem entendre com: ***Fes servir una seq√º√®ncia interna complint l'est√†ndard SQL***. Aix√≤ substitueix l'antic comportament del SERIAL. Vincula la columna a una seq√º√®ncia num√®rica (1, 2, 3...) per√≤ la lliga a l'estructura de la taula de manera segura (si esborres la taula, s'esborra la seq√º√®ncia autom√†ticament).

### `SERIAL` vs `GENERATED BY DEFAULT AS IDENTITY`

| Caracter√≠stica | SERIAL (M√®tode Antic) | GENERATED ... AS IDENTITY (M√®tode Modern) |
| :--- | :--- | :--- |
| **Estandarditzaci√≥** | ‚ùå **No Est√†ndard.** √âs una invenci√≥ espec√≠fica de PostgreSQL. Altres bases de dades no ho entenen. | ‚úÖ **Est√†ndard SQL.** Compleix la normativa ISO SQL:2003. Facilita la portabilitat. |
| **Naturalesa** | √âs un **"pseudo-tipus"** (una drecera o macro) que crea una seq√º√®ncia per darrere. | √âs una **propietat de la columna**. La base de dades gestiona la identitat nativament. |
| **Gesti√≥ de Permisos** | ‚ö†Ô∏è **Manual.** Si dones perm√≠s d'escriptura a la taula, sovint has de donar perm√≠s expl√≠cit a la seq√º√®ncia tamb√©. | ‚úÖ **Autom√†tica.** Els permisos sobre la seq√º√®ncia estan lligats als de la taula. |
| **Control d'Inserci√≥ Manual** | üîì **Permissiu.** Sempre permet inserir un ID manualment, cosa que pot desincronitzar la seq√º√®ncia. | üîí **Configurable.** Pots triar `BY DEFAULT` (permissiu) o `ALWAYS` (estricte: bloqueja insercions manuals). |
| **Depend√®ncia** | La columna dep√®n de la seq√º√®ncia. Si esborres la columna malament, la seq√º√®ncia pot quedar "√≤rfena". | La seq√º√®ncia √©s un atribut intern de la columna. Si esborres la columna, tot desapareix netament. |
| **Rendiment** | ‚ö° Molt r√†pid (fa servir seq√º√®ncies). | ‚ö° Igual de r√†pid (tamb√© fa servir seq√º√®ncies internament). |
| **Recomanaci√≥ (PostgreSQL 10+)** | üìâ **Obsolet.** Es mant√© per compatibilitat amb codi antic. | üìà **Recomanat.** √âs la manera correcta de treballar avui dia. |

## DDL - *Data Definition Language*
Es un llenguatge que, fent servir certes sent√®ncies SQL, ens permet **definir** l'estructura de les dades. Dit d'una altra manera, son les instruccions que farem servir per construir l'estructura de la nostra base de dades.

Consta de 4 ordres:
- `CREATE`: Ens permet crear parts de l'estructura tals com la propia **base de dades**, **taules**, **vistes**...
- `ALTER`: Ens permet alterar o modificar l'estructura, com per exemple, **afegir columnes** a una taula o **canviar el tipus de dada d'una columna**
- `DROP`: Ens permet eliminar una part de l'estructura. Podem eliminar una **columna**, una **taula** o **tota la base de dades** si cal
- `TRUNCATE`: Ens permet eliminar tot el contingut de la taula pero mantenint l'estructura
    >[!NOTE]
    >El que fa realment `TRUNCATE` es eliminar la taula (`DROP`) i tornar-la a crear (`CREATE`) tot en una i sense que ho haguem de fer nosaltres expl√≠citament. Es per aix√≥ que aquesta operaci√≥ la classifiquem com `DDL` i no com `DML`. Sempre que volguem esborrar **TOTS** els registres de la taula, es una opci√≥ m√©s recomanable a efectes de rendiment que fer un `DELETE FROM nom_taula`.

### Definici√≥ de la propia base de dades
#### Crear la base de dades
```sql
CREATE DATABASE nom_base_de_dades;
```

#### Crear la base de dades indicant el seu **propietari**
```sql
CREATE DATABASE nom_base_de_dades OWNER usuari;
```

#### Eliminar la base de dades
```sql
DROP DATABASE nom_base_de_dades;
```

#### Renombrar la base de dades
```sql
ALTER DATABASE nom_antic RENAME TO nom_nou;
```

### Definici√≥ de taules

#### Crear taula

Crear una taula definint alguns camps
```sql
CREATE TABLE clients (
    id GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,    
    posicio_ranking INTEGER DEFAULT 0,
    saldo DECIMAL DEFAULT 0,
    actiu BOOLEAN DEFAULT true
);
```

#### Crear taula amb clau forana
```sql
CREATE TABLE usuaris (
    id GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    dept_id INTEGER REFERENCES usuaris(id) --dept_id es una clau forana que apunta a la clau primaria d'usuaris (id)
);
```

#### Eliminar taula
```sql
DROP TABLE nom_taula;
```

#### Buidar la taula (eliminem els registres que cont√© pero no la taula)
```sql
TRUNCATE TABLE nom_taula;
```

#### Canviar el nom de la taula
```sql
ALTER TABLE nom_taula_actual RENAME TO nom_taula_nou;
```

#### Afegir columnes
```sql
ALTER TABLE nom_taula ADD COLUMN nom_columna tipus_de_dada;
```

#### Eliminar columna
```sql
ALTER TABLE nom_taula DROP COLUMN nom_columna;
```

#### Modificar columna
```sql
ALTER TABLE nom_taula ALTER COLUMN nom_columna TYPE nou_tipus_de_dada;
```

#### Canviar els camps tipus SERIAL per camps GENERATED ALWAYS AS IDENTITY
```sql
-- 1. Elimina el vincle amb la seq√º√®ncia antiga (el mecanisme del SERIAL)
ALTER TABLE "CLIENT" ALTER COLUMN "Id" DROP DEFAULT;

-- 2. (Opcional per√≤ recomanat) Esborra la seq√º√®ncia vella que ha quedat √≤rfena
-- Normalment es diu NomTaula_Camp_seq
DROP SEQUENCE IF EXISTS "CLIENT_Id_seq";

-- 3. Afegeix la nova propietat d'Identitat estricta (ALWAYS)
ALTER TABLE "CLIENT" ALTER COLUMN "Id" 
ADD GENERATED ALWAYS AS IDENTITY;
```
Com encara no tenim valors, potser eliminareu la taula i la tornareu a crear. Pero tingueu en compte que a un model amb dades existents no podriem esborrar la taula i tamb√© hauriem de gestionar que el comptador de la seq√º√®ncia no perdi el valor actual.


## DML - Data Manipulation Language
Es un llenguatge que, fent servir certes sent√®ncies SQL, ens permet manipular les dades. Dit d'una altra manera, son les instruccions que farem servir per afegir i modificar contingut a la base de dades que hem definit pr√®viament. Ens permet realitzar les operacions **CRUD** (Create, Read, Update, Delete) fent servir les seg√ºents sent√®ncies:

### `INSERT`
Les sent√®ncies `INSERT` son les que ens permeten **inserir** o afegir informaci√≥ a la nostra base de dades en forma de **registres** a les taules. Podem entendre cada registre com una fila de la taula.

Per exemple, si volem inserir un registre a la taula usuaris que hem creat als exemples previs:

```sql
INSERT INTO usuaris (nom, email, detp_id)
VALUES ('Gregorio Esteban S√°nchez Fern√°ndez', 'dongregorio@gmail.com', 2);
```

>[!NOTE]
>No hem d'informar tots els camps de la taula a l'insert, nom√©s els que volguem (o els que no ens quedi m√©s remei perque no admeten NULLS).
>
>En aquest cas no he informat el camp `id` ja que es un `IDENTITY` que, a m√©s, es `GENERATED ALWAYS`, de manera que si l'intento informar jo manualment ens tirar√† un error.

### `UPDATE`

### `SELECT`

### `DELETE`
